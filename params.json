{"name":"Gamenave2","tagline":"Trabalho a ser feito para o professor de POO2, como um dos requisitos para nota","body":"**TRABALHO DA DISCIPLINA PROGRAMAÇÃO ORIENTADA A OBJETOS 2**\r\n\r\n**Projeto: Jogo Nave**\r\n\r\n**1.\tRegistro de Alterações**\r\n\r\n\r\n**Versão** = 2\r\n\r\n**Responsáveis** = Izabely Corrêa e Gislaine Almeida\r\n\r\n**Data** = 21/10/2015\r\n\r\n**Alterações** = \r\n* Diagrama de Classes, \r\n* Diagrama de Composição MVC, \r\n* Diagrama de Padrões, \r\n* Explicação do uso dos Padrões, \r\n* Descrição da Utilização MVC e \r\n* Refatoração\r\n\r\n**2.\tIntrodução**\r\n\r\n\r\nEste documento apresenta um relatório de projeto e engenharia do sistema de um jogo de naves. Este documento está organizado da seguinte forma: a seção 3 apresenta o padrão Fábrica utilizado, seus respectivos  diagramas, motivações e explicações, a seção 4 apresenta o padrão Builder utilizado, seus respectivos  diagramas, motivações e explicações , a seção 5 demonstra o diagrama de classes e o de composição de estruturas e descreve a utilização MVC, a seção 6 demonstra a diferença evidenciada com a refatoração do código.\r\n\r\n**3.\tPadrão Fábrica**\r\n\r\nAplicada a Objetos nas Fases do Jogo: Naves e Itens\r\n ![](https://github.com/izabely-furtado/GameNave2/blob/master/diagramas/PadraoFabrica.png?raw=true)\r\n\r\n\r\n**3.1.\tMotivo da Utilização**\r\n\r\n\r\nO padrão em questão foi utilizado para fabricação de objetos que estarão em cada fase, sendo esses itens e/ou naves.\r\n\r\nO Factory Method foi utilizado para esse projeto, pois nessas condições o padrão nos oferece um meio de desligar a implementação de um produto final em si. Por exemplo, caso quisesse desenvolver um novo inimigo, a criação deste estaria facilitada e em nível de chamada, pode-se chamar qualquer nave inimiga, como uma nave ou simplesmente um objeto. \r\n\r\nAlém disso, o padrão fábrica, faz com que não haja repetição de código, dado que caso queira fabricar um novo item, poderia já abstrair este como um objeto e somente implementar as modificações ocasionadas no jogo. Mas isso tudo é feito de forma mais intuitiva, como uma espécie de montagem facilitadora, uma casca que define a criação de elementos presentes em cada classe. Assim, há um local único para ser modificado, assim, um local único para fazer manutenção, dando um código flexível e extensível no futuro.\r\n\r\nPara completar, caso o uma nave específica ou um item precise ser desligado ou deletado, a alteração não irá afetar demais classes, principalmente não irá afetar seu “criador”, pois eles não estarão fortemente ligados. Facilitando, assim, a manutenção do código, pois encapsula esse comportamento de instanciação.\r\n\r\n **3.2.\tExplicação do Diagrama**\r\n\r\n\r\nNo diagrama de classe acima temos a classe FabricaAtributoAcao definida como interface (já que Python não possui interface ela é apenas uma classe abstrata com funções abstratas) que define os métodos que deverão ser implementados por sua subclasse, a classe abstrata FabricaObjeto.\r\n\r\nAmbas classes, tanto FabricaItem, quanto FabricaNave, que estendem a classe FabricaObjeto serão objetos na tela que possuem o mesmo comportamento de, ou seja, se movem e possuem uma figura que os representa. Estendendo de FabricaObjeto, possuem os atributos e podem utilizar e/ou sobrescrever os métodos existentes no super.\r\n\r\nNo diagrama de classes temos a classe FabricaObjeto como abstrata que define atributos que cabem a qualquer nave e objeto no jogo, além dos métodos que definem comportamentos comuns entre as naves e itens e que deverão ser sobrescritos por cada subclasse, que são:\r\n* move()\r\n* criaVelocidade() \r\n\r\n\r\nIsso deve ser feito, pois cada nave possui seu próprio movimento, velocidade e, já que é uma nave também, sua própria resistência, no caso de um item, este deve possuir suas próprias modificações.\r\n\r\n\r\n**3.2.1.\tFabrica Naves**\r\n\r\n\r\n**3.2.1.1.\tInimigas**\r\n\r\n\r\nTodas as naves inimigas devem conter o dado referente sobre a pontuação que o jogador arrecada por derrota-la, sendo que a explosão ficou igual a todas as naves por conveniência, no entanto, só algumas naves inimigas atiram.\r\n\r\nSendo assim, temos a classe FabricaNaveInimiga como abstrata estende FabricaNave e define atributos que cabem a qualquer nave inimiga, além disso, as classes que a estende, sobrescrevem as funções necessárias para toda nave, já mencionadas.\r\nAlguns naves inimigas, além de implementarem as funções mencionadas, implementam atributos e métodos que possibilitam atirar.\r\n\r\n\r\n**3.2.1.2.\tJogador**\r\n\r\n\r\nA Nave do Jogador é análoga a qualquer nave, só que esta deve permitir que o jogador possa atirar em seus inimigos. \r\n\r\n\r\n**3.2.2.\tFabrica Itens**\r\n\r\n\r\nCada item faz modificações na nave ou no status do jogador e, como tal, possui seu preço, caso queira ser trocada por uma pontuação e a probabilidade de aparecimento durante uma fase. Além de possuir os atributos e métodos que estão no super estendido, FabricaObjeto.\r\n\r\n\r\n**4.\tPadrão Builder**\r\n\r\n\r\nAplicada a Naves\r\n ![](https://github.com/izabely-furtado/GameNave2/blob/master/diagramas/PadraoBuild.png?raw=true)\r\n\r\n\r\n**4.1.\tMotivo da Utilização**\r\n\r\n\r\nA motivação foi separar a construção de um objeto complexo de sua representação de modo que o mesmo processo de construção possa criar diferentes representações.\r\n\r\nNesse caso deu à separação da fabricação de uma nave, do dano causado a mesma, do som que esta emite e da imagem referente a ela e sua explosão. Seguindo em si, a mesma ideia dos padrões Factory Method e Abstract Factory. No entanto, permitindo separar os passos da construção da nave em pequenos métodos que são:\r\n* BuildDano()\r\n* BuildImagemNave()\r\n* BuildImagemExplosao()\r\n* BuildSom()\r\n\r\n\r\nNo padrão Builder temos também uma interface comum para todos os objetos que constroem outros objetos. Essa interface Builder define todos os passos necessários para construir  cada tipo de nave, sendo essa a de um jogador ou inimiga.\r\n\r\n\r\n**4.2.\tExplicação do Diagrama**\r\n\r\n\r\n**4.2.1.\tNaveProduct**\r\n\r\n\r\nNada mais é do que uma estrutura de dados que armazena as informações de uma nave. A nossa classe Builder vai possui um método para construir cada um dos dados do produto em questão.\r\n\r\n\r\n**4.2.2.\tNaveBuilder**\r\n\r\n\r\nNesta classe temos a nave que será construída, os passos para sua construção e um método que devolve a nave construída. \r\n\r\nEstá classe em questão é abstrata os métodos em si serão implementados por cada classe abstrata que o estender, não existindo assim um “algoritmo” bem definido, o algoritmo será definido em outro lugar nos filhos.  Sendo assim, em cada uma das classes que o estender esses métodos implementar estarão “personalizando” a nave.\r\n\r\n\r\n**4.2.3.\tNaveJogoDirector**\r\n\r\n\r\nA classe chamada de Director, utiliza a estrutura do Builder para definir o algoritmo de construção do Produto.\r\n\r\nSendo que, dado um Builder, a classe vai executar os métodos de construção, definindo assim o algoritmo de construção de naves, e depois devolve nave. O código cliente vai lidar apenas com o Director, toda a estrutura e algoritmos utilizados para construir a nave fica por debaixo dos panos.\r\n\r\n\r\n**5.\tMVC**\r\n\r\n**Diagrama de Composição de Estruturas**\r\n ![](https://github.com/izabely-furtado/GameNave2/blob/master/diagramas/ComposicaoEstrutural.png?raw=true)\r\n\r\nEsse diagrama destina-se a descrição dos relacionamentos entre os elementos. Utilizado para descrever a colaboração interna de classes, interfaces ou componentes para especificar uma funcionalidade.\r\n\r\nEssa colaboração interna começa a se basear no modelo MVC, que se trata de um padrão de arquitetura de software que separa a representação da informação da interação do usuário com ele. Utilizando-se das ideias centrais por trás do MVC, que são a reusabilidade de código e separação de conceitos.\r\n\r\nO modelo consiste nos dados da aplicação, regras de negócios, lógica e funções, que nesse caso estão na CamadaDomínioProblema, que possui as classes que foram indicadas no diagrama de classes.\r\n\r\nUma visão pode ser qualquer saída de representação dos dados, que estão na CamadaGestaoDados, como as músicas tocadas no jogo e as imagens que demonstram as naves a as munições, por exemplo.  Assim como podem ser representação de dados que pode se haver uma interação, como botões e janelas, que estão na CamadaInteraçãoHumana.\r\n\r\nO controlador faz a mediação da entrada, convertendo-a em comandos para o modelo ou visão, estão nesse caso na CamadaControleInterface.\r\n\r\nAssim, a partir disse a camada de aplicação da nave, chama em uma linha a função da CamadaControleInterface  a função que chama o menu inicial.\r\n\r\n**6.\tRefatoração**\r\n\r\n\r\nFazer isso usando SONAR\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}